// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5506.Stronghold.commands;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Joystick.RumbleType;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc5506.Stronghold.Robot;

/**
 *
 */
public class DriveTeleop extends Command {
	public boolean usingTankDrive = true;
	public boolean isHoldingButton = false;
	public double minimumInput = 0.03; // The joystick has a slight margin of error, never perfectly at 0

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public DriveTeleop() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	if(Robot.oi.getDriverJoystick().getRawButton(9) && !isHoldingButton) {
    		isHoldingButton = true;
    		usingTankDrive = !usingTankDrive;
    	} else if(!Robot.oi.getDriverJoystick().getRawButton(9) && isHoldingButton) {
    		isHoldingButton = false;
    	}
    	if(usingTankDrive) {
	    	float leftSpeed = (float) Robot.oi.getDriverJoystick().getRawAxis(1);
	    	float rightSpeed = (float) Robot.oi.getDriverJoystick().getRawAxis(5);
	    	tankDrive(leftSpeed, rightSpeed);
    	} else {
        	arcadeDrive();
    	}
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
    
    private void tankDrive(float leftSpeed, float rightSpeed) {
    	if(Math.abs(leftSpeed) >= minimumInput) {
    		Robot.driveTrain.driveLeft(leftSpeed);
    		rumble(Robot.oi.getDriverJoystick(), true, Math.abs(leftSpeed));
    	} else {
    		Robot.driveTrain.driveLeft(0);
    		rumble(Robot.oi.getDriverJoystick(), true, 0);
    	}
    	if(Math.abs(rightSpeed) >= minimumInput) {
    		Robot.driveTrain.driveRight(rightSpeed);
    		rumble(Robot.oi.getDriverJoystick(), false, Math.abs(rightSpeed));
    	} else {
    		Robot.driveTrain.driveRight(0);
    		rumble(Robot.oi.getDriverJoystick(), false, 0);
    	}
    }
    
    private void arcadeDrive() {
    	double forwardSpeed = Robot.oi.getDriverJoystick().getY() * -1;
    	double turningSpeed = Robot.oi.getDriverJoystick().getX() * -1;
    	if (Math.abs(forwardSpeed) < minimumInput)
    		forwardSpeed = 0;
    	if (Math.abs(turningSpeed) < minimumInput)
    		turningSpeed = 0;
    	if (Math.abs(Robot.oi.getDriverJoystick().getX()) > Math.abs(Robot.oi.getDriverJoystick().getY())) {
        	Robot.oi.getDriverJoystick().setRumble(RumbleType.kLeftRumble, (float) Math.abs(Robot.oi.getDriverJoystick().getX()));
        	Robot.oi.getDriverJoystick().setRumble(RumbleType.kRightRumble, (float) Math.abs(Robot.oi.getDriverJoystick().getX()));
    	} else {
        	Robot.oi.getDriverJoystick().setRumble(RumbleType.kLeftRumble, (float) Math.abs(Robot.oi.getDriverJoystick().getY()));
        	Robot.oi.getDriverJoystick().setRumble(RumbleType.kRightRumble, (float) Math.abs(Robot.oi.getDriverJoystick().getY()));
    	}
    	Robot.driveTrain.drive(forwardSpeed, turningSpeed);
    }
    
    /**
     * Rumble the joystick for a certain amount
     * @param joy the joystick to rumble
     * @param left is left or right rumble?
     * @param amount amount to rumble
     */
    private void rumble(Joystick joy, boolean left, float amount) {
    	if(left) {
    		joy.setRumble(RumbleType.kLeftRumble, amount);
    	} else {
    		joy.setRumble(RumbleType.kRightRumble, amount);
    	}
    }
}
